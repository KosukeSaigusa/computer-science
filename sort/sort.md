# sort（整列）

## 参考

- [栢木先生の基本情報技術者教室](https://www.amazon.co.jp/dp/B0821W2G51/ref=dp-kindle-redirect?_encoding=UTF8&btkr=1)
- [コンピュータ・サイエンス第 2 ソート（整列） アルゴリズム：オーダー](http://sv.c.titech.ac.jp/minamide/2018/CS2/day4/day4.pdf)
- [Wikipedia マージソート](https://ja.wikipedia.org/wiki/%E3%83%9E%E3%83%BC%E3%82%B8%E3%82%BD%E3%83%BC%E3%83%88)
- [アルゴリズムとデータ構造](http://www.dais.is.tohoku.ac.jp/~shioura/teaching/ad11/ad11-02.pdf)
- [ソート問題とアルゴリズム](http://www.akita-pu.ac.jp/system/elect/ins/kusakari/japanese/teaching/SoftTech/2010/note/3.pdf)

## アルゴリズムの実行時間のオーダー

アルゴリズムの実行時間のオーダーとは、十分大きな `n` に対して、実行時間の増加がどのような関数の定数倍に比例するかを意味する。

## バブルソート

バブルソート（bubble sort, 基本交換法, 隣接交換法）は、隣り合う要素を比較し、逆順であれば交換して整列を行う方法である。

例として、`A = [4, 1, 3, 2]` という配列を昇順にソートすることを考える。

1 回目の操作郡では、0 番目の要素から 3 番目の要素を左から順に比較・並べ替えする操作を行う。

- 1-0: `[4, 1, 3, 2]`（`A[0]` と `A[1]` を比較 --> 交換あり）
- 1-1: `[1, 4, 3, 2]`（`A[1]` と `A[2]` を比較 --> 交換あり）
- 1-2: `[1, 3, 4, 2]`（`A[2]` と `A[3]` を比較 --> 交換あり）
- 1-3: `[1, 3, 2, 4]`（1 回目の操作郡の完了)

この時点で最後尾の要素が最も大きい（つまり最後尾の要素はこれ以上並べ替えが必要ない）ことが保証されているので、2 回目の操作郡では、0 番目の要素から 2 番目の要素について左から順に比較・並べ替えする操作を行えば良い。

- 2-0: `[1, 3, 2, 4]`（`A[0]` と `A[1]` を比較 --> 交換なし）
- 2-1: `[1, 3, 2, 4]`（`A[1]` と `A[2]` を比較 --> 交換あり）
- 2-2: `[1, 2, 3, 4]`（2 回目の操作郡の完了)

この時点で、`A[2]` と `A[3]` の位置が正しいことが保証されているので、3 回目の操作郡では、`A[0]` と `A[1]` を比較すれば良い。

このような操作を繰り返すので、バブルソートの比較回数は

```
(n-1) + (n-2) + (n-3) + ... + 1 = n(n-1)/2
```

で、配列の長さのみに依存し、`O(n^2)` である。

一方、交換の回数は並び方に依存するので、プログラムの実行時間は初期状態によって異なる。

アルゴリズムを擬似的に書くと次のようになる。

```
for (i=n-1, n-2, n-3, ..., 1) {
    for (j=0, 1, 2, ..., n-2) {
        if (A[j] > A[j+1]) {
            tmp = A[j];
            A[j] =  A[j+1];
            A[j+1] = tmp;
        } else {
            // 交換なし
        }
    }
}
```

## 選択ソート

選択ソート（selection sort, 基本選択法）は、対象集合から最も小さい（または大きい）要素を順次取り出して、端に並べていくことで整列を行う方法である。

`N` 個の要素の中から最小のものを選択するためには、`N-1` 回の比較が必要となり、その次の操作では残りの `N-1` 個の要素の中で最小のものを選択するために `N-2` 回の比較が必要となる。

このような操作を繰り返すので、選択ソートの比較回数は

```
(n-1) + (n-2) + (n-3) + ... + 1 = n(n-1)/2
```

で、配列の長さのみに依存し、`O(n^2)` である。

## 挿入ソート

挿入ソート（insertion sort, 基本挿入法）は、対象集合から順次要素を取り出し、それまでに取り出してきた要素の集合に対して、正しい順序関係を保つ適切な位置に新しい要素を挿入していくことで整列を行う方法である。

例として、`A = [4, 1, 3, 2]` という配列を昇順にソートすることを考える。

まず最初の要素である 4 を取り出す。

- 整列済：`[4]`
- 未整列：`[1, 3, 2]`

そして、次の要素である 1 を取り出し、4 と比較して適切な位置に挿入する。

- 整列済：`[1, 4]`
- 未整列：`[3, 2]`

次の要素である 3 を取り出し、`[1, 4]` と比較して適切な位置に挿入する。この時の比較回数は 2 回である。

- 整列済：`[1, 3, 4]`
- 未整列：`[2]`

最後に、2 を `[1, 3, 4]` と比較して適切な位置に挿入する。この時の比較回数は、2 回である（1, 3 と比較してその間に入ると分かった時点でそれより後ろの 4 と比較する必要はない）。

- 整列済：`[1, 2, 3, 4]`
- 未整列：`[]`

以上より入力配列の並び方によって比較回数が異なることも見て取れる。このようなアルゴリズムに対しては、最悪の場合と平均的な場合のそれぞれでオーダーを解析するのが妥当である。

最悪な場合では、新しい要素の挿入時に整列済みの配列のすべての要素と比較を必要とするような状態（入力配列が並べ替えが完了した後の配列のちょうど逆順であるとき）を想定するので、その比較回数は

```
1 + 2 + ... + (n-2) + (n-1) = n(n-1)/2
```

で、`O(n^2)` であるため、バブルソートや選択ソートと同じである。

平均的な場合は、`n` 個の整列対象の要素のうち、`i` (`i=1, 2, ..., n-1`) 個の要素が整列済みであるときに、新しい要素の挿入を行う際の最小の比較回数である 1 回と、最大の比較回数である `i-1` 回 の平均、つまり `i/2` 回の比較が行われると想定して、その比較回数は

```
1/2 + 2/2 + 3/2 + ... + (n-2)/2 + (n-1)/2 = n(n-1)/4
```

で、最悪の場合の半分となるが、やはり `O(n^2)` である。

一方で、何らかの理由で入力配列がすでに整列されている場合には有効な手法となる。

## マージソート

マージソート (merge sort) とは、入力配列を要素数が 1 つになるまで 2 分割することを繰り返し、各データ列内のデータをソートした後、2 組ずつの各要素を適切な順番に並び替えながらもとに戻していく（マージしていく）ことで整列を行う方法である。

例として、`A = [8, 4, 3, 7, 6, 5, 2, 1]` という配列を昇順にソートすることを考える。

まず、入力配列を 2 分割する。（区切りは `|` で表記した。）

`A = [8, 4, 3, 7 | 6, 5, 2, 1]`

再度、配列を 2 分割する。

`A = [8, 4 | 3, 7 | 6, 5 | 2, 1]`

最後にもう一度配列を 2 分割する。

`A = [8 | 4 | 3 | 7 | 6 | 5 | 2 | 1]`

この時点で、各データ列のデータ数が 1 つになったので、隣同士の 2 要素ずつをソートしてマージする。

`A = [4, 8 | 3, 7 | 5, 6 | 1, 2]`

左の 2 つのデータ列と、右の 2 つのデータ列をそれぞれソートしつつマージし、全体を 2 つのデータ列に戻す。

`A = [3, 4, 7, 8 | 1, 2, 5, 6]`

2 つのデータ列をそれぞれソートしつつマージし、全体を 1 つのデータ列に戻す。

`A = [1, 2, 3, 4, 5, 6, 7, 8]`

という流れで、マージソートは行われる。

また、マージの際に具体的にどのような操作が行われているかを補足する。そこで、マージ前の配列をそれぞれ次のような `A1`, `A2` とし、マージした結果を格納するための空の配列を `A` とする。

`A1 = [3, 4, 7, 8]`, `A2 = [1, 2, 5, 6]`

`A = []`

マージする際に行うのは、`A1` と `A2` の先頭の要素同士を比較し、小さい方を新しい配列 `A` の先頭に移動するという比較と操作である。つまり、まず `A1[0] = 3` と `A2[0] = 1` を比較して、小さい方の 1 を `A` の最初の要素とする。

`A1 = [3, 4, 7, 8]`, `A2 = [2, 5, 6]`

`A = [1]`

次は、`A1[0] = 3` と `A2[0] = 2` を比較して、次のような操作結果となる。

`A1 = [3, 4, 7, 8]`, `A2 = [5, 6]`

`A = [1, 2]`

さらに、`A1[0] = 3` と `A2[0] = 5` を比較して、次のような操作結果となる。

`A1 = [4, 7, 8]`, `A2 = [5, 6]`

`A = [1, 2, 3]`

以上を繰り返すことで並べ替えの済んだマージ後の配列が生成されることになる。このようなマージ前の各配列の先頭を比べるだけで並び替えが可能になるのは、マージ前の配列 `A1`, `A2` がそれぞれの中で整列を済ませているからである。

`A1` と `A2` の要素数が `i` (`1 < i < n`) であるとき、それをマージするのに必要な操作は、

- `A1` と `A2` の先頭要素の比較：最小 `i` 回, 最大 `2i` 回
- `A` への書き込み：最小：`i+1` 回, 最大 `2i` 回

であると分かり、このような計算量は配列の要素数 `n` に比例する。

また、要素数 `n`（簡単のため `n=2^x` を想定する）の配列について、要素数 1 になるまで分割した状態から、`log2(n)` 回のマージ操作を行うとソートが完了するため、マージソートのオーダーは最悪の場合も平均の場合も `O(n*log(n))` であると言える（オーダーは定数倍に関してはその違いを問題としないため、対数の底も記述する必要はない）。

## クイックソート

クイックソートとは、入力配列の値に対して適当な基準値を設けて、それよりも小さな値を集めた区分と大きな値を集めた区分に要素を振り分け、さらにそれぞれの区分の中で同様の処理を繰り返し行うことで整列を行う方法である。

例として、`A = [8, 4, 3, 7, 6, 5, 2, 1]` という配列を昇順にソートすることを考える。

基準値（ピボット）を決定する。ここでは配列の中央付近に位置する `A[3] = 7` を基準として、それより小さな値の区分と大きな値の区分に振り分ける。

`A = [8, 4, 3 | 7 | 6, 5, 2, 1]`

具体的には、まず初期配列の左から 7 以上の値を探索して 8 を発見、また、初期配列の右から 7 未満の値を探索して 1 を発見する。そこで、1 と 8 の位置を入れ替える。

`A = [1, 4, 3 | 7 | 6, 5, 2, 8]`

前回の続きで、左から 7 以上の値を探索して 7 を発見、右から 7 未満の値を探索して 2 を発見する。そこで、7 と 2 の位置を入れ替える。

`A = [1, 4, 3, 2, 6, 5 | 7 | 8]`

前回の続きで、左から 7 以上の値を探索して 7 を発見、右から 7 未満の値を探索して 5 を発見する。すでに 7 が 5 よりも右（大きい）側に存在しているので入れ替えなしで、探索終了。この時点で、後ろ側の `[7, 8]` の位置が確定する。

そこで、クイックソートの対象を `[1, 4, 3, 2, 6, 5]` のみに限定し、中央付近の `3` を基準値とし探索を開始する。

`A = [1, 4 | 3 | 2, 6, 5] / [7, 8]`

左から 3 以上の値を探索して 4 を発見、右から 3 未満の値を探索して 2 を発見。両者の位置を入れ替える。

`A = [1, 2 | 3 | 4, 6, 5] / [7, 8]`

左から 3 以上の値を探索して 3 を発見、右から 3 未満の値を探索して 2 を発見するが、すでに 3 が 2 よりも右（大きい）側に存在しているので入れ替えなしで、探索終了。この時点で、前側の `[1, 2, 3]` の位置が確定する。

そこで、クイックソートの対象を `[4, 6, 5]` のみに限定し、中央の `6` を基準値とし探索を開始する。

`A = [1, 2, 3] / [4 | 6 | 5] / [7, 8]`

左から 6 以上を探索して 6 を発見。右から 6 未満を探索して 5 を発見。両者を入れ替える。

`A = [1, 2, 3] / [4, 5 | 6 |] / [7, 8]`

左から 6 以上を探索して 6 を発見。右から 6 未満を探索して 5 を発見。すでに 6 が 5 よりも右（大きい）側に存在しているので入れ替えなしで、探索終了。この時点で、後ろ側の `[4, 5, 6]` の位置が確定する。

以上で、全体の並べ替えが、`A = [1, 2, 3, 4, 5, 6, 7, 8]` の昇順となって完了。

クイックソートの計算時間のオーダーを考える。

最悪の場合は、基準値がいつも

`A = [[空] | 基準値 | [その他全ての要素]]`

のようになってしまうとき（例えば毎回偶然基準値に最小値を選択してしまう場合）で、残された要素数が `i` 個 (`1 < i < n`) であるとき、毎回 `i-1` 回の比較を必要としてしまう。

つまり、クイックソートの最悪の場合のオーダーは `O(n^2)` である。

平均的には、全体の時間計算量を `T(n)` とし、基準値に `i` 番目の値を選択した場合、小さい方の分割を再帰的にソートするのに要する時間は `T(i-1)`, 大きい方の分割を再帰的にソートするのに要する時間は `T(n-i)` と言え、分割の位置の決定のための探索の計算量は `c(n-1)` （`c`: 定数）と表せることから、次のような漸化式が成立する。

```
T(n) <= T(i-1) + T(n-i) + c(n-1)
```

基準値の順位は、`i = 1, 2, ..., n` のそれぞれについて均等（平均的）に起こることを想定するので、それらの総和を総数 `n` で割ることで、平均の計算量とすることができる。

```
T(n) <= (1/n) * Σ[i=1, ..., n](T(i-1) + T(n-i) + c(n-1))
```

過程は省略するが、この漸化式を解いて、クイックソートの平均計算時間料は `O(n*log(n))` となる。

## ソートアルゴリズムのオーダーの限界

データ同士の比較に基づくソートアルゴリズムのオーダーは、`O(n*log(n))` が最小であることが知られている。

## まとめ

| 手法           | 平均          | 最悪          | コメント                     |
| -------------- | ------------- | ------------- | ---------------------------- |
| バブルソート   | `O(n^2)`      | `O(n^2)`      | 常に `n(n-1)/2` 回の比較     |
| 選択ソート     | `O(n^2)`      | `O(n^2)`      |                              |
| 挿入ソート     | `O(n^2)`      | `O(n^2)`      | 整列済みの配列については高速 |
| マージソート   | `O(n*log(n))` | `O(n*log(n))` | 安定して比較回数が少ない     |
| クイックソート | `O(n*log(n))` | `O(n^2)`      |                              |
